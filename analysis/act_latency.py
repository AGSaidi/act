#!/usr/bin/python

#-------------------------------------------------
# act_latency.py
#
# Analyze an act_storage or act_index output file.
# Typical usage:
#    $ ./act_latency.py -l act_out.txt
# where act_out.txt is output generated by act_storage or act_index, and which
# uses defaults:
# (-h - depends on config found in act_out.txt)
# -t 3600
# -s 0
# -n 7
# -e 1
# (-x - not set)
#-------------------------------------------------


#===========================================================
# Imports.
#

import getopt
import re
import sys


#===========================================================
# Constants.
#

BUCKET_LABELS = ("00", "01", "02", "03", "04", "05", "06", "07", "08", "09",
    "10", "11", "12", "13", "14", "15", "16")
ALL_BUCKETS = len(BUCKET_LABELS)
BUCKET_PATTERNS = [re.compile('.*?\(' + b + ': (.*?)\).*?')
    for b in BUCKET_LABELS]
GAP = "  "


class Hist(object):
    def __init__(self, name, max_bucket):
        self.name = name

        self.pre_pad = ""
        self.old_total = 0
        self.old_values = [0] * max_bucket
        self.slice_total = 0
        self.slice_values = [0] * max_bucket
        self.rate = 0.0
        self.avg_rate = 0.0
        self.max_rate = 0.0
        self.overs = [0.0] * max_bucket
        self.avg_overs = [0.0] * max_bucket
        self.max_overs = [0.0] * max_bucket


#===========================================================
# Function definitions.
#

#-------------------------------------------------
# Parse a histogram total from a act output line.
#
def read_total_ops(line, file_id):
    total = long(line[line.find("(") + 1: line.find(" total)")])
    line = file_id.readline()
    return total, line

#-------------------------------------------------
# Get one set of bucket values.
#
def read_bucket_values(line, file_id, max_bucket, hist):
    values = [0] * max_bucket
    total, line = read_total_ops(line, file_id)
    b_min = 0
    while True:
        found = 0
        for b in range(b_min, max_bucket):
            r = BUCKET_PATTERNS[b]
            if r.search(line):
                found += 1
                values[b] = long(r.search(line).group(1))
        if found == 0:
            break
        line = file_id.readline()
        b_min += found
    hist.slice_total = total - hist.old_total
    hist.old_total = total
    hist.slice_values = [a - b for a,b in zip(values, hist.old_values)]
    hist.old_values = values
    return line

#-------------------------------------------------
# Get the data chunk reported by act at the specified after_time.
#
def read_chunk(file_id, after_time, max_bucket, hists):
    find_line = "After " + str(after_time) + " "
    while True:
        line = file_id.readline()
        if not line:
            return False
        if line.startswith(find_line):
            break
    got_chunk = False
    line = file_id.readline()
    while line and line.strip():
        for hist in hists:
            if line.startswith(hist.name):
                line = read_bucket_values(line, file_id, max_bucket, hist)
                got_chunk = True
                break
        else:
            line = file_id.readline()
    return got_chunk

#-------------------------------------------------
# Get the percentage excesses for every bucket.
#
def bucket_percentages_over(total, values, max_bucket):
    percentages = [0.0] * max_bucket
    if total == 0:
        return percentages
    delta = 0
    for b in range(max_bucket):
        delta += values[b]
        percentages[b] = round(((total - delta) * 100.0) / total, 2)
    return percentages

#-------------------------------------------------
# Print a latency data output line.
#
def print_slice_line(slice_tag, hists, start_bucket, max_bucket, every_nth,
        extra=False):
    output = "%5s" % (slice_tag) + GAP
    for hist in hists:
        output += hist.pre_pad
        for i in range(start_bucket, max_bucket, every_nth):
            output += "%7.2f" % (hist.overs[i])
        if extra:
            output += "%11.1f" % (hist.rate)
        output += GAP
    print output

#-------------------------------------------------
# Print a latency average data output line.
#
def print_avg_line(hists, start_bucket, max_bucket, every_nth, extra=False):
    output = "  avg" + GAP
    for hist in hists:
        output += hist.pre_pad
        for i in range(start_bucket, max_bucket, every_nth):
            output += "%7.2f" % (hist.avg_overs[i])
        if extra:
            output += "%11.1f" % (hist.avg_rate)
        output += GAP
    print output

#-------------------------------------------------
# Print a latency maximum data output line.
#
def print_max_line(hists, start_bucket, max_bucket, every_nth, extra=False):
    output = "  max" + GAP
    for hist in hists:
        output += hist.pre_pad
        for i in range(start_bucket, max_bucket, every_nth):
            output += "%7.2f" % (hist.max_overs[i])
        if extra:
            output += "%11.1f" % (hist.max_rate)
        output += GAP
    print output

#-------------------------------------------------
# Print usage.
#
def usage():
    print "Usage:"
    print " -l act_storage or act_index output file"
    print "    MANDATORY - NO DEFAULT"
    print "    e.g. act_out.txt"
    print " -h histogram to analyse"
    print "    default: depends on config read from output file"
    print " -t analysis slice interval in seconds"
    print "    default: 3600"
    print " -s start display from this bucket"
    print "    default: 0"
    print " -n number of buckets to display"
    print "    default: 7"
    print " -e show start bucket then every n-th bucket"
    print "    default: 1"
    print " -x (show extra information for each slice)"
    print "    default: not set"

#-------------------------------------------------
# Main function.
#
def main(arg_log, arg_histograms, arg_slice, arg_start_bucket, arg_num_buckets,
        arg_every_nth, arg_extra):
    # Sanity-check the arguments:
    if arg_log is None:
        usage()
        sys.exit(-1)
    if arg_slice < 1:
        print "slice must be more than 0"
        sys.exit(-1)
    if arg_start_bucket < 0 or arg_start_bucket >= ALL_BUCKETS:
        print "start_bucket must be non-negative and less than " + ALL_BUCKETS
        sys.exit(-1)
    if arg_num_buckets < 1:
        print "num_buckets must be more than 0"
        sys.exit(-1)
    if arg_every_nth < 1:
        print "every_nth must be more than 0"
        sys.exit(-1)

    # Find index + 1 of last bucket to display:
    for b in range(arg_start_bucket, ALL_BUCKETS, arg_every_nth):
        max_bucket = b + 1
        if arg_num_buckets == 1:
            break
        else:
            arg_num_buckets = arg_num_buckets - 1

    # Open the log file:
    try:
        file_id = open(arg_log, "r")
    except:
        print "log file " + arg_log + " not found"
        sys.exit(-1)

    # Find and echo the version:
    line = file_id.readline()
    while line and not line.startswith("ACT version"):
        line = file_id.readline()
    if not line:
        print arg_log + " ACT version not found"
        sys.exit(-1)
    version = line.split(" ")[2].strip()
    print arg_log + " is ACT version " + version + "\n"
    numeric_version = float(version)
    if numeric_version < 5.0 or numeric_version >= 6.0:
        print arg_log + " ACT version not compatible"
        sys.exit(-1)

    # Find the reporting interval:
    line = file_id.readline()
    while line and not line.startswith("report-interval-sec"):
        line = file_id.readline()
    if not line:
        print "can't find report interval"
        sys.exit(-1)
    interval = long(line.split(" ")[1])
    if interval < 1:
        print "reporting interval must be more than 0"
        sys.exit(-1)

    # Find the histograms' scale:
    scale_label = " %>(ms)"
    file_id.seek(0, 0)
    line = file_id.readline()
    while line and not line.startswith("microsecond-histograms"):
        line = file_id.readline()
    if not line:
        print "can't find histograms' scale, assuming milliseconds"
        file_id.seek(0, 0)
    elif line.split(" ")[1].startswith("y"):
        scale_label = " %>(us)"

    # Adjust the slice time if necessary:
    slice_time = ((arg_slice + interval - 1) / interval) * interval
    if slice_time != arg_slice:
        print "analyzing time slices of " + str(slice_time) + " seconds"

    # Echo the config from the log file:
    file_id.seek(0, 0)
    line = file_id.readline()
    while line and not line.endswith("CONFIGURATION\n"):
        line = file_id.readline()
    if not line:
        print "can't find configuration"
        sys.exit(-1)
    line = line.strip()
    if line.startswith("ACT-STORAGE"):
        if not arg_histograms:
            arg_histograms = ["READS", "RAW READS"]
    elif line.startswith("ACT-INDEX"):
        if not arg_histograms:
            arg_histograms = ["TRANS READS", "RAW READS"]
    else:
        print "can't recognize configuration"
        sys.exit(-1)
    while line:
        print line
        line = file_id.readline().strip()
    print ""
    line = file_id.readline()
    while line and not line.startswith("DERIVED CONFIGURATION"):
        line = file_id.readline()
    if not line:
        print "can't find derived configuration"
        sys.exit(-1)
    line = line.strip()
    while line:
        print line
        line = file_id.readline().strip()
    print ""

    hists = [Hist(name, max_bucket) for name in arg_histograms]

    # Print the output table header:
    prefix = "slice"
    threshold_labels = ""
    threshold_underline = ""
    for i in range(arg_start_bucket, max_bucket, arg_every_nth):
        threshold_labels += "%7s" % (pow(2, i))
        threshold_underline += " ------"
    if arg_extra:
        threshold_labels += "       rate"
        threshold_underline += " ----------"
    len_table = len(threshold_labels)
    for i in range(1, len(hists)):
        prev_name_len = 1 + len(hists[i - 1].name)
        if prev_name_len > len_table:
            hists[i].pre_pad = " " * (prev_name_len - len_table)
    names_out = " " * len(prefix)
    units_out = " " * len(prefix)
    labels_out = prefix
    underline_out = "-" * len(prefix)
    for hist in hists:
        names_out += GAP + " " + hist.name.ljust(len_table - 1)
        units_out += GAP + hist.pre_pad + scale_label.ljust(len_table)
        labels_out += GAP + hist.pre_pad + threshold_labels
        underline_out += GAP + hist.pre_pad + threshold_underline
    print names_out
    print units_out
    print labels_out
    print underline_out

    # Initialization before processing time slices:
    which_slice = 0
    after_time = slice_time

    # Process all the time slices:
    while True:
        if not read_chunk(file_id, after_time, max_bucket, hists):
            # Note - we ignore the (possible) incomplete slice at the end.
            break

        for hist in hists:
            hist.rate = round(float(hist.slice_total) / slice_time, 1)
            if arg_extra:
                hist.avg_rate += hist.rate
                if hist.rate > hist.max_rate:
                    hist.max_rate = hist.rate
            hist.overs = bucket_percentages_over(
                hist.slice_total, hist.slice_values, max_bucket)
            for i in range(arg_start_bucket, max_bucket, arg_every_nth):
                hist.avg_overs[i] += hist.overs[i]
                if hist.overs[i] > hist.max_overs[i]:
                    hist.max_overs[i] = hist.overs[i]

        # Print this slice's percentages over thresholds:
        which_slice += 1
        print_slice_line(which_slice, hists, arg_start_bucket, max_bucket,
            arg_every_nth, arg_extra)

        # Prepare for next slice:
        after_time += slice_time

    # Print averages and maximums:
    if which_slice:
        for hist in hists:
            if arg_extra:
                hist.avg_rate /= which_slice
            for i in range(arg_start_bucket, max_bucket, arg_every_nth):
                hist.avg_overs[i] /= which_slice
        print underline_out
        print_avg_line(hists, arg_start_bucket, max_bucket, arg_every_nth,
            arg_extra)
        print_max_line(hists, arg_start_bucket, max_bucket, arg_every_nth,
            arg_extra)
    else:
        print "could not find " + str(slice_time) + " seconds of data"


#===========================================================
# Execution.
#

# Echo the command line arguments.
print "act_latency.py " + " ".join(sys.argv[1:])

# Read the input arguments:
try:
    opts, args = getopt.getopt(sys.argv[1:], "l:h:t:s:n:e:x",
        ["log=", "histogram=", "slice=", "start_bucket=", "num_buckets=",
         "every_nth=", "extra"])
except getopt.GetoptError, err:
    print str(err)
    usage()
    sys.exit(-1)

# Default values for arguments:
arg_log = None
arg_histograms = []
arg_slice = 3600
arg_start_bucket = 0
arg_num_buckets = 7
arg_every_nth = 1
arg_extra = False

# Set the arguments:
for o, a in opts:
    if o == "-l" or o == "--log":
        arg_log = a
    if o == "-h" or o == "--histogram":
        arg_histograms.append(a)
    if o == "-t" or o == "--slice":
        arg_slice = long(a)
    if o == "-s" or o == "--start_bucket":
        arg_start_bucket = int(a)
    if o == "-n" or o == "--num_buckets":
        arg_num_buckets = int(a)
    if o == "-e" or o == "--every_nth":
        arg_every_nth = int(a)
    if o == "-x" or o == "--extra":
        arg_extra = True

# Call main():
main(arg_log, arg_histograms, arg_slice, arg_start_bucket, arg_num_buckets,
    arg_every_nth, arg_extra)
